---
title: 散列（hash）
date: 2024-03-16 22:01:17
tags:
    - 数据结构
categories:
    - [数据结构]
---
# 散列（hash）

散列是一种能够以常数平均时间执行插入、删除和查找的技术。但是散列无法做到元素间的有序。

## 基本想法

散列的基本想法就是将元素按照一定的规则处理后，映射到散列表中的某个位置，比如是0到tablesize - 1的某个数，这样就可以保证能够快速的找到元素位置。这种映射就叫做**散列函数**（哈希函数）。但是要保证任意两个不同的元素也能够被映射到不同的位置是几乎不可能实现的，因为在数学逻辑中，等于是将一个大的集合映射到一个小的集合中，两个不同大小的集合要实现一对一的映射关系是不可能的。
那么剩下的问题就是如果出现了冲突要怎么解决，以及如果来确定散列表的大小。

## 散列函数

最容易想到的散列函数莫过于直接使用元素值来和tablesize取模，但如果元素具有某些不理想的性质，就不是那么好了。比如tablesize取10，而元素恰好很多个位上是0，那么直接取模就是一个坏的选择。相对好的方法是控制表的大小是一个素数，例如tablesize取11，那对于上述的元素也可以很好的平均分配位置。
另外，如果元素是不可以直接运算的，比如是字符串类型，那么散列函数的设计就需要考虑更多的因素，比如可以取字符的ASCII码，或者用字符串的字符数量等等，但这些都不是很好的选择。写出一个散列函数并不难，但是写出一个好的散列函数其实是非常困难的。好的散列函数能做到的是尽可能**快而均匀**的将元素分配到散列表中。一个散列函数能被称为好的散列函数，一定是在某种使用场景下，结合了场景的特性设计出来的。

## 分离链接法

分离散列表是一种解决冲突的做法，其做法是将冲突的元素以链表的形式串起来，标准库中的`unordered_map`就是采用了这种方式。这种方式对空间的要求比较大，因为这些表双向链接且浪费空间，如果空间比较吃紧，那么最好还是不要使用这种形式。

![分离链接表](/images/chaining_hash_table.jpg)

为了执行一次搜索，先使用散列函数确定是在哪一个链表中，然后再在这个链表中执行一次遍历查找。执行插入时，也是先通过散列函数找到要插入的链表，并且检查是否已经有了该元素，如果没有那么就将这个新元素插入到开头位置。
> 为什么是开头位置？这是基于这样一种事实：往往新插入的元素最有可能在不久就被访问到。

```c++

```

## 不使用链表的散列表

## 再散列(rehash)

## 常数时间访问的散列表

## 通用散列

## 磁盘上的散列